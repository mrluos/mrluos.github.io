<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>js执行上下文[Execution Context] · mrluo</title><meta name="description" content="js执行上下文[Execution Context] - mrluo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/style.css"><!-- fonts--><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" href="http://fonts.lug.ustc.edu.cn/css?family=Source+Sans+Pro:400,600" type="text/css"><!-- baidu analytics--><script type="text/javascript">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?3ee91d14584b24f0f7509f558e910b42";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script></head><body><input type="checkbox" id="sidebar-toggle"><aside><div class="author"><a href="/."><img src="/img/author.png" class="author-img"></a><h2 class="author-name">mrluo</h2></div><div class="post-toc"><span class="toc-title">Directory</span><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#why"><span class="toc-text">why</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#执行上下文-execution-context-分类"><span class="toc-text">执行上下文(execution context)分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#执行上下文-execution-context-操作"><span class="toc-text">执行上下文(execution context)操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#执行上下文是如何创建的？"><span class="toc-text">执行上下文是如何创建的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol></div></aside><div class="main"><header><div id="top"><a href="/." class="logo-link">mrluo</a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">Home</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">Archive</a></li><li class="nav-list-item"><a href="/tags/" target="_self" class="nav-list-link">Tags</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">Rss</a></li><li class="nav-list-item"><a href="/sitemap.xml" target="_self" class="nav-list-link">Sitemap</a></li></ul></div></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">js执行上下文[Execution Context]</h1><div class="post-time">Apr 12, 2016</div><div class="post-content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本篇记录在JavaScript中代码的运行环境，也就是执行上下文概念,清楚javascript引擎内部在执行代码前做了些什么，解释为什么某些函数以及变量在没有被声明就可以被使用。</p>
<h3 id="why"><a href="#why" class="headerlink" title="why"></a>why</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// function b()&#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(d); <span class="comment">// 异常：d is no defined</span></span><br><span class="line"><span class="keyword">var</span> a= <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c =<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">d =<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="执行上下文-execution-context-分类"><a href="#执行上下文-execution-context-分类" class="headerlink" title="执行上下文(execution context)分类"></a>执行上下文(execution context)分类</h3><p>可执行上下文（简称EC）是一个抽象的概念，在ECMA262中用他来区分不同类型的可执行代码。<br>首先需要分清楚的是在js中，有以下不同类型的可执行上下文：</p>
<p><strong>全局代码</strong>：这类的代码是在<code>程序</code>级别上被处理的，例如加载的外部js代码或者是内联的js代码（script标签内的代码块）,全局代码不包括任何函数体内的js代码。  </p>
<p><strong>函数代码</strong>：当执行一个函数时，运行函数体中的代码（这里不包括函数内部的函数）。  </p>
<p><strong>eval执行的代码</strong>：使用内部函数eval执行的时候。  </p>
<blockquote>
<p>换个角度说就是js解释器在执行js code时候的执行的环境.</p>
</blockquote>
<a id="more"></a>
<p>下面来看一个代码片段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> globalStr=<span class="string">'hi'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> str=<span class="string">'my name is '</span>,</span><br><span class="line">		last=<span class="string">'luo'</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">getStr</span>(<span class="params"></span>)&#125;</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> str;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">getLast</span>(<span class="params"></span>)&#125;</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> last;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">console</span>.log(globalStr+<span class="string">','</span>+getStr()+<span class="string">' '</span>+ getLast());</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure></p>
<p>上面的代码块一共有4个不同的执行上下文</p>
<ul>
<li>test函数的外层的<code>全局上下文</code></li>
<li>test函数内部代码 的<code>执行上下文</code>(函数类型的EC)</li>
<li>getStr函数内部代码 的<code>执行上下文</code>(函数类型的EC)</li>
<li>getLast函数内部代码 的<code>执行上下文</code>(函数类型的EC)</li>
</ul>
<p>其中<code>全局上下文</code>只会有一个，其他函数的上下文（或者是eval的上下文）可以有多个.</p>
<h3 id="执行上下文-execution-context-操作"><a href="#执行上下文-execution-context-操作" class="headerlink" title="执行上下文(execution context)操作"></a>执行上下文(execution context)操作</h3><p>分析完了上下文的类型，我们来看看在内部是怎么对这些上下文进行管理操作的。<br>首先我们需要知道，js的解释器在浏览器中是<code>单线程</code>运行的，也就是说在一个时间内只能<code>同时</code>进行一个事件的处理，其他的事件会被加入到一个序列内，我们叫它<code>执行上下文的堆栈</code>.   大概的模拟是这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [];</span><br></pre></td></tr></table></figure></p>
<p>我们接着拿上面的代码来说，在程序初始的时候我们的堆栈是这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">	globalContext <span class="comment">/*存储的是上面分析的第一个（test函数外层）上下文*/</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<p>当<code>执行</code>test()的时候，会把这个函数的EC(这里简写)加入到堆栈内:</p>
<blockquote>
<p>注意这里是执行的时候才创建一个执行上下文</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">	testFunContext,</span><br><span class="line">	globalContext <span class="comment">/*存储的是上面分析的第一个（test函数外层）上下文*/</span></span><br><span class="line">	</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>然后逐步的加入剩下2个内部函数的EC到这个堆栈中,最终堆栈是：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">	testinner2FunContext,</span><br><span class="line">	testinner1FunContext,</span><br><span class="line">	testFunContext,</span><br><span class="line">	globalContext </span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<p>上面阐述入栈的一个过程，那什么时候EC从这个栈移除呢？<br>在说出栈前我们需要了解的一个过程是，前面说到解释器在执行的时候只能同时操作一个，这里解释器的流程重复的去栈内的最后一个元素执行。<br>当函数结束或者返回的时候就会退出当前活动的EC，这个时候就是出栈，（当抛出异常的时候，也会退出相关的EC，直到栈内只剩下全局的EC）.</p>
<p>来看看下面的程序：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i === <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        foo(++i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="number">0</span>));</span><br></pre></td></tr></table></figure></p>
<p>下面这个gif图演示了上面这个代码的上下文在栈内操作的一个过程  </p>
<img src="/2016/04/12/js执行上下文-Execution-Context/es1.gif" alt="示意图" title="示意图">  
<p><strong>关于执行上下文的栈操作,我们可以总结出5个关键的点:  </strong></p>
<ul>
<li>单线程</li>
<li>同步执行</li>
<li>一个全局的执行上下文</li>
<li>无限的个函数上下文</li>
<li>每个函数调用的时候会创建一个新的执行上下文，包括函数自身的调用（自己调用自己）.  </li>
</ul>
<h3 id="执行上下文是如何创建的？"><a href="#执行上下文是如何创建的？" class="headerlink" title="执行上下文是如何创建的？"></a>执行上下文是如何创建的？</h3><p>上面抽象的讲了解释器是如何操作EC的，接着我们来看看每个EC内是如何运行的。<br>EC的代码被分成两个基本的阶段来处理：</p>
<ul>
<li><strong>进入EC</strong>（<code>调用函数，在实际执行内部代码前</code>）：<ul>
<li>创建一个<a href="wwww.baidu.com">作用域链</a>。</li>
<li>创建变量、函数声明(这里注意是函数的声明，不是<code>函数表单式</code>两者的<a href="www.baidu.com">区别</a>？)、arguments对象和参数。</li>
<li>确认<code>this</code>的值。<blockquote>
<p>这里我把它叫做确认变量阶段</p>
</blockquote>
</li>
</ul>
</li>
<li><strong>执行代码</strong><ul>
<li>变量赋值，函数引用，和执行其它代码  <blockquote>
<p>这里我把它叫做赋值阶段</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>这里我们再发挥一下想象,对于EC来说在阶段1时创建了一系列的变量，方便后面阶段2时的使用，所以这些必须存储起来，我们这里抽象一下EC的结构大概是这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">executionContextObj=&#123;</span><br><span class="line">   scopeChain: &#123; <span class="comment">/*作用域链*/</span>&#125;,</span><br><span class="line">   variableObject: &#123;<span class="comment">/*存放创建的变量、函数声明等*/</span>&#125;,</span><br><span class="line">   <span class="keyword">this</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中关于<a href="www.baidu.com">scopeChain</a>、<a href="www.baidu.com">variableObject</a> 、<a href="www.baidu.com">this</a>.还有更深入的知识，我们这里为了理解EC先提及不深究。</p>
<p>下面我们还是通过一个模拟代码来解释一下阶段一和阶段二。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'d'</span>,d); <span class="comment">//function d()&#123;&#125;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'e'</span>,e);<span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">1111</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> e = <span class="function"><span class="keyword">function</span> <span class="title">_e</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">10</span>); <span class="comment">// call</span></span><br></pre></td></tr></table></figure></p>
<p>当函数test调用，随即创建了一个EC(函数类型的EC) ,在EC创建的时候首先是阶段一：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">executionContextObj=&#123;</span><br><span class="line">   scopeChain: &#123;...&#125;,</span><br><span class="line">   <span class="comment">//我们重点看这里</span></span><br><span class="line">   variableObject = &#123;</span><br><span class="line">	  a: <span class="number">10</span>,</span><br><span class="line">	  b: <span class="literal">undefined</span>,</span><br><span class="line">	  c: <span class="literal">undefined</span>,</span><br><span class="line">	  d: &lt;声明函数的引用&gt;</span><br><span class="line">	  e: undefined</span><br><span class="line">   &#125;,</span><br><span class="line">   this: &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后是阶段二<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">executionContextObj=&#123;</span><br><span class="line">   scopeChain: &#123;...&#125;,</span><br><span class="line">   <span class="comment">//我们重点看这里,开始赋值了和引用</span></span><br><span class="line">   variableObject = &#123;</span><br><span class="line">	  a: <span class="number">10</span>,</span><br><span class="line">	  b: <span class="literal">undefined</span>,</span><br><span class="line">	  c: <span class="number">11111</span>,</span><br><span class="line">	  d: &lt;声明函数的引用&gt;</span><br><span class="line">	  e: &lt;函数表达式_e的引用&gt;</span><br><span class="line">   &#125;,</span><br><span class="line">   this: &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面我们可以看出，d(函数声明) 和e（函数表达式）函数的区别,这里也就能解释为什么上面的d输出是function d(){},e输入的是undefined。<br>现在知道文章开头的答案了吧。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/#first-article" target="_blank" rel="external">What is the Execution Context &amp; Stack in JavaScript?</a><br><a href="http://goddyzhao.tumblr.com/post/10020230352/execution-context" target="_blank" rel="external">执行上下文（Execution Context）</a></p>
</div></article></div><div class="tags"><a href="/tags/js/">js</a><a href="/tags/js深入系列/">js深入系列</a><a href="/tags/js执行上下文-Execution-Context/">js执行上下文(Execution Context)</a></div><div class="paginator"><a href="/2016/04/12/变量对象（Variable object）/" class="prev"><i class="fa fa-chevron-left"></i><span> Prev</span></a><a href="/2016/04/12/js中的作用域/" class="next"><span>Next</span><i class="fa fa-chevron-right"></i></a></div></section><footer><section id="comments"><div data-thread-key="http://mrluos.coding.io/2016/04/12/js执行上下文-Execution-Context/index.html" data-title="js执行上下文[Execution Context]" data-url="http://mrluos.coding.io/2016/04/12/js执行上下文-Execution-Context/index.html" class="ds-thread"></div><script type="text/javascript">var duoshuoQuery = {short_name: "mrluos" };
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></section><div class="copyright"><p>© 2016<span class="heart"><i class="icon-next-heart fa fa-heart"></i></span><a href="http://mrluos.coding.io">mrluo</a></p></div></footer></div><label for="sidebar-toggle" class="sidebar-menu"><div class="menu"></div></label><label class="back2top"> <a href="#top"><div class="arrow"></div></a></label></body></html>