<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>变量对象（Variable object） · mrluo</title><meta name="description" content="变量对象（Variable object） - mrluo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/style.css"><!-- fonts--><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" href="http://fonts.lug.ustc.edu.cn/css?family=Source+Sans+Pro:400,600" type="text/css"><!-- baidu analytics--><script type="text/javascript">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?3ee91d14584b24f0f7509f558e910b42";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script></head><body><input type="checkbox" id="sidebar-toggle"><aside><div class="author"><a href="/."><img src="/img/author.png" class="author-img"></a><h2 class="author-name">mrluo</h2></div><div class="post-toc"><span class="toc-title">Directory</span><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Variable-object变量对象-VO"><span class="toc-text">Variable object变量对象(VO)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不同EC下的VO"><span class="toc-text">不同EC下的VO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#全局上下文中的VO"><span class="toc-text">全局上下文中的VO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数上下文中的VO"><span class="toc-text">函数上下文中的VO</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量对象（VO）于EC的两个阶段的关系"><span class="toc-text">变量对象（VO）于EC的两个阶段的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#进入EC"><span class="toc-text">进入EC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#执行代码"><span class="toc-text">执行代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#误区"><span class="toc-text">误区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol></div></aside><div class="main"><header><div id="top"><a href="/." class="logo-link">mrluo</a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">Home</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">Archive</a></li><li class="nav-list-item"><a href="/tags/" target="_self" class="nav-list-link">Tags</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">Rss</a></li><li class="nav-list-item"><a href="/sitemap.xml" target="_self" class="nav-list-link">Sitemap</a></li></ul></div></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">变量对象（Variable object）</h1><div class="post-time">Apr 12, 2016</div><div class="post-content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前面我们讲过js的执行上下文(EC)，我们知道一个EC的创建分成2个阶段，进入EC和执行code。<br>在进入EC阶段，解释器会扫描出当前EC中声明的变量、函数和传递的参数数据，并把这些数据存储到一个变量对象(VO)中，下面我们来仔细看看这个VO(Variable object变量对象).</p>
<h3 id="Variable-object变量对象-VO"><a href="#Variable-object变量对象-VO" class="headerlink" title="Variable object变量对象(VO)"></a>Variable object变量对象(VO)</h3><p>Variable object简称VO是一个跟EC相关的特殊的抽象对象，每一个EC都会关联一个变量对象,它是用来存储以下内容：</p>
<ul>
<li>函数的形参(arguments)</li>
<li>函数声明（FD）, 这里注意<code>是函数声明不是函数表达式</code></li>
<li>变量声明（var）</li>
</ul>
<p>vo是执行上下文EC的属性，用代码表示逻辑可以表示成这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">activeExecutionContext&#123;</span><br><span class="line">	VO:&#123;</span><br><span class="line">		<span class="comment">// 存储变量声明、函数声明和函数形参</span></span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>例如下面的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num= <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> b= <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对应的vo结构实现大概抽象成是这样的</span></span><br><span class="line">VO(全局EC)&#123;</span><br><span class="line">	num:<span class="number">10</span>,</span><br><span class="line">	test:&lt;test 函数的引用&gt;</span><br><span class="line">&#125;</span><br><span class="line">VO(函数test的EC)&#123;</span><br><span class="line">	a:10,</span><br><span class="line">	b:20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于VO，有几点注意：</p>
<ol>
<li>VO内属性的名称就是我们声明的变量或函数的名称。</li>
<li>在全局EC中，允许通过VO的属性名来间接访问。（下面会详细说）</li>
<li>非全局的EC，不允许通过VO的属性名来间接访问。</li>
<li>vo在解释器底层，是一个抽象的东西，因此不同的EC下vo的名称和初始的结构不同。</li>
</ol>
<blockquote>
<p>VO是对于解释器层的使用，相当于内部使用的私有属性,所以不能不能直接访问。</p>
</blockquote>
<h3 id="不同EC下的VO"><a href="#不同EC下的VO" class="headerlink" title="不同EC下的VO"></a>不同EC下的VO</h3><p>上面我们也说了VO是一个抽象的事物，不同的EC下有所不同，但是对于VO的一些操作（例如初始化）和行为是相同的.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AbstractVO (generic behavior of the variable instantiation process)</span><br><span class="line"> </span><br><span class="line">  ║</span><br><span class="line">  ╠══&gt; GlobalContextVO</span><br><span class="line">  ║        (VO === this === global)</span><br><span class="line">  ║</span><br><span class="line">  ╚══&gt; FunctionContextVO</span><br><span class="line">           (VO === AO, &lt;arguments&gt; object and &lt;formal parameters&gt; are added)</span><br></pre></td></tr></table></figure></p>
<h4 id="全局上下文中的VO"><a href="#全局上下文中的VO" class="headerlink" title="全局上下文中的VO"></a>全局上下文中的VO</h4><p>首先我们需要明确<code>全局对象</code>的概念</p>
<blockquote>
<p>全局对象在进入任何执行上下文前就创建，并且只存在一个（全局对象），你可以在程序的任意地方使用它的属性，全局对象的生命周期结束于程序的退出.</p>
</blockquote>
<p>在全局对象创建的时候，会初始化一些属性例如：Math,String,Date,parseInt等等，还会添加一个指向全局对象本身的引用。<br>例如在浏览器中，window属性就是全局对象的一个引用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">global = &#123;</span><br><span class="line">  <span class="built_in">Math</span>: &lt;...&gt;,</span><br><span class="line">  String: &lt;...&gt;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  window: global</span><br><span class="line">&#125;;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">因为全局对象是不能通过名称直接访问的，所以当访问全局对象的属性时，通常忽略前缀。但是通过全局上下文的this还是有可能直接访问到全局对象的，同样的我们可以通过引用自身的属性来访问，例如DOM中的window.</span><br><span class="line">```javascript</span><br><span class="line">String(10);</span><br><span class="line"> //意思是 全局.String(10)因为全局对象不能用名称直接访问所以就简写成String.</span><br><span class="line">window.a=1;// === 全局.window.a = 10 === 全局.a = 10;</span><br><span class="line">this.b=10; // 全局.b=10</span><br><span class="line"></span><br><span class="line">var  testObj=&#123;</span><br><span class="line">	nme:'mrluo'</span><br><span class="line">&#125;</span><br><span class="line">testObj.mrluo // 这里能通过名字'testObj'来访问到它内部的属性。</span><br></pre></td></tr></table></figure></p>
<p>因此，全局上下文中的变量对象就是全局对象自身<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VO(globalContext) === global;</span><br></pre></td></tr></table></figure></p>
<p>所以在全局上下文中声明一个变量时，我们够通过全局对象的属性间接访问到这个变量(例如，当事先未知变量名时)：</p>
<h4 id="函数上下文中的VO"><a href="#函数上下文中的VO" class="headerlink" title="函数上下文中的VO"></a>函数上下文中的VO</h4><p>在函数的EC中，VO是不能直接访问的，因此在函数的EC中会创建一个叫<code>&quot;激活对象（activiation object 缩写AO）&quot;</code>来代替VO<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VO(functionContext)===AO</span><br></pre></td></tr></table></figure></p>
<p>AO是在进入函数EC的时候创建的，相对于全局的VO，AO多了一个特殊参数(arguments)对象。</p>
<blockquote>
<p>前面说了VO是一个抽象的概念，根据不同的EC，会有所差异，这里就体现出来了。</p>
</blockquote>
<h3 id="变量对象（VO）于EC的两个阶段的关系"><a href="#变量对象（VO）于EC的两个阶段的关系" class="headerlink" title="变量对象（VO）于EC的两个阶段的关系"></a>变量对象（VO）于EC的两个阶段的关系</h3><p>上一篇<a href="/2016/04/12/执行上下文(Execution-Context)/" title="执行上下文(Execution-Context)">执行上下文(Execution-Context)</a>,我们提到了EC创建分成2个阶段:  </p>
<ul>
<li>进入EC</li>
<li>执行代码</li>
</ul>
<h4 id="进入EC"><a href="#进入EC" class="headerlink" title="进入EC"></a>进入EC</h4><p>进入EC的时候，VO会被下列属性填充，具体如下(区分顺序)：</p>
<ol>
<li>函数的所有形参,(如果是函数上下文)<br>vo的一个属性，这个属性以函数形参命名，形参的值为值，如果没有传递参数，则值为undefined</li>
<li>所有的函数声明<br>vo的一个属性，这个属性以声明的函数对象的名称命名，函数对象的值为值，如果变量对象已经存在相同名称的属性，则完全替换这个属性。</li>
<li>所有的变量声明<br>vo的一个属性，这个属性以变量名称命名，值为undefined，如果变量名称跟已经声明的形参或者函数相同，则变量不会对已经存在的属性造成影响。（如果存在形参或者函数声明，则变量声明不起效）</li>
</ol>
<p>用代码来解释上面说的顺序和规则<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a,b,c</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'before'</span>,a,b,c,d);</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> d= <span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">	(<span class="function"><span class="keyword">function</span> <span class="title">aa</span> (<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'after'</span>,a,b,c,d);</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">10</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure></p>
<p>当进入test函数EC的时候，AO是这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AO(test)&#123;</span><br><span class="line"> 	<span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="number">1</span>: <span class="number">20</span>,</span><br><span class="line">        length: <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">	a:<span class="number">10</span>, <span class="comment">//参照上面的描述第一点</span></span><br><span class="line">	b: reference to FunctionDeclaration <span class="string">"b"</span>,<span class="comment">//这里并不是形参b的值20. 参照上面的描述第二点</span></span><br><span class="line">	c: <span class="literal">undefined</span>,</span><br><span class="line">	d: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的AO中并不存在属性aa,因为aa是一个函数表达式，并不是函数的声明，所以这里并不会存储到这个AO中。（函数声明和函数表达式区别?）<br>介绍了第一阶段，下面接着来看看第二阶段<strong>执行代码</strong></p>
<h4 id="执行代码"><a href="#执行代码" class="headerlink" title="执行代码"></a>执行代码</h4><p>通过上一步的操作，现在的AO/VO已经初始化了EC内所有符合的属性，但是部分的属性还是初始的undefined值。<br>还是拿上面的代码来说，当EC进入到这个阶段，AO会变成这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AO(test)&#123;</span><br><span class="line">	<span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="number">1</span>: <span class="number">20</span>,</span><br><span class="line">        length: <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">	a: <span class="number">1</span>,</span><br><span class="line">	b: reference to FunctionDeclaration <span class="string">"b"</span>,</span><br><span class="line">	c: <span class="literal">undefined</span>,</span><br><span class="line">	d: reference to FunctionDeclaration <span class="string">"e"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个阶段会对属性进行赋值的操作.</p>
<p>看了上面的介绍知道了EC不同阶段下VO的操作，下面来看看一个例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">alert(x); <span class="comment">// function</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">alert(x); <span class="comment">// 10</span></span><br><span class="line"> </span><br><span class="line">x = <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">alert(x); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure></p>
<p>为什么第一个alert “x” 的返回值是function，而且它还是在“x” 声明之前访问的“x” 的？为什么不是10或20呢？因为，根据规范2当进入上下文时，往VO里填入函数声明；在相同的阶段，还有一个变量声明“x”，那么正如我们在上一个阶段所说，变量声明在顺序上跟在函数声明和形式参数声明之后，而且，在这个阶段变量声明不会干扰VO中已经存在的同名函数声明或形式参数声明，因此，在进入上下文时，VO的结构如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VO[<span class="string">'x'</span>] = <span class="number">10</span>;</span><br><span class="line">VO[<span class="string">'x'</span>] = <span class="number">20</span>;</span><br></pre></td></tr></table></figure></p>
<p>还有下面的这个例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">alert(a); <span class="comment">// 1</span></span><br><span class="line">alert(b); <span class="comment">// undefined,b属性存在VO，值为undefined.</span></span><br></pre></td></tr></table></figure></p>
<p>上面的例子并不是像想象中一样，条件成立声明a不成立声明b.</p>
<h3 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h3><p>使用var和不用的区别是，不用var是全局变量？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b=<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	c=<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure></p>
<p>上面的a和b,引用Dmitry Soshnikov的话来描述：<br><blockquote><p>just create the new property (but not the variable) of the global object.</p>
<footer><strong>Dmitry Soshnikov</strong><cite><a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/" target="_blank" rel="external">Variable Object</a></cite></footer></blockquote><br>只是创建了一个全局的属性，并不是变量，这里说的“不是变量”，并不是说它不能改变，只是说这种写法是不符合ECMAScript变量规范。<br>之所以上面的code能不出错的运行是因为前面说过的全局的VO===global.</p>
<p>关于是用var申明后赋值和不用直接赋值的区别？</p>
<ol>
<li>使用var申明的叫变量（也叫显式申明），是不可以使用delete操作符的。</li>
<li>直接赋值也叫隐式申明，它会在全局对象中创建一个属性，是可以使用delete操作符的。</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/" target="_blank" rel="external">ECMA-262-3 in detail. Chapter 2. Variable object</a></p>
<p><a href="http://bclary.com/log/2004/11/07/#a-10.1.3" target="_blank" rel="external">Variable Instantiation</a></p>
</div></article></div><div class="tags"><a href="/tags/js/">js</a><a href="/tags/js变量对象/">js变量对象</a><a href="/tags/js深入系列/">js深入系列</a></div><div class="paginator"><a href="/2016/04/12/执行上下文(Execution-Context)/" class="next"><span>Next</span><i class="fa fa-chevron-right"></i></a></div></section><footer><section id="comments"><div data-thread-key="http://mrluos.coding.io/2016/04/12/变量对象（Variable object）/index.html" data-title="变量对象（Variable object）" data-url="http://mrluos.coding.io/2016/04/12/变量对象（Variable object）/index.html" class="ds-thread"></div><script type="text/javascript">var duoshuoQuery = {short_name: "mrluos" };
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></section><div class="copyright"><p>© 2016<span class="heart"><i class="icon-next-heart fa fa-heart"></i></span><a href="http://mrluos.coding.io">mrluo</a></p></div></footer></div><label for="sidebar-toggle" class="sidebar-menu"><div class="menu"></div></label><label class="back2top"> <a href="#top"><div class="arrow"></div></a></label></body></html>